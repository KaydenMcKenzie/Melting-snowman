<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Melting Snowman Hangman — Per-Part Drops</title>
<meta name="description" content="Hangman with a custom snowman where each part drops on a wrong guess.">
<style>
  /* ====== Theme ====== */
  :root{
    --bg:#0b1b2b; --card:#10304b; --ink:#eaf6ff; --accent:#8fd3ff;
    --good:#7ee081; --bad:#ff7d7d;
  }
  *{box-sizing:border-box}
  body{
    margin:0;min-height:100vh;display:flex;align-items:center;justify-content:center;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
    background:var(--bg);color:var(--ink)
  }
  .app{width:min(1100px,96vw);display:grid;grid-template-columns:1fr 1fr;gap:26px;align-items:stretch}
  .card{background:var(--card);border-radius:16px;padding:18px 20px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
  h1{margin:0 0 10px;color:var(--accent);font-size:22px;letter-spacing:.4px}

  /* ====== Game UI ====== */
  .meta{display:flex;gap:10px;flex-wrap:wrap;margin:6px 0 14px}
  .tag{background:#163b59;border-radius:999px;padding:6px 10px;font-size:12px;opacity:.9}
  .blanks{display:flex;gap:10px;flex-wrap:wrap;font-size:28px;letter-spacing:.2rem}
  .blank{border-bottom:3px solid var(--ink);min-width:28px;text-align:center;padding:4px 2px}
  .blank.space{border-bottom:0;min-width:12px}
  .used{font-size:13px;opacity:.85}
  .keyboard{display:grid;grid-template-columns:repeat(13,1fr);gap:8px;margin-top:10px}
  button.key{padding:10px 0;border-radius:10px;border:0;background:#1b486d;color:var(--ink);cursor:pointer;font-weight:700}
  button.key:disabled{opacity:.35;cursor:default}
  .actions{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
  .actions button{background:#245d86;color:var(--ink);border:0;border-radius:10px;padding:10px 14px;font-weight:700;cursor:pointer}
  .status{min-height:28px;margin-top:10px;font-size:18px}
  .good{color:var(--good)} .bad{color:var(--bad)}

  /* ====== Scene & Snowman (layered PNGs) ====== */
  .scene{
    position:relative;border-radius:16px;overflow:hidden;min-height:460px;
    display:flex;align-items:center;justify-content:center;background:linear-gradient(#0f2f4d,#0b1b2b)
  }
  .ground{position:absolute;inset:auto 0 0 0;height:26%;background:linear-gradient(#eaf6ff,#cfeaff)}
  .snowman-wrap{position:relative;width:min(480px,86%);aspect-ratio:3/4}
  .part{position:absolute;left:0;top:0;width:100%;height:100%;object-fit:contain;pointer-events:none;will-change:transform}

  /* ====== New: per-part drop animation (no fading) ====== */
  /* We drop to ~115% of the snowman box height so it lands on the ground band */
  @keyframes drop {
    0%   { transform: translateY(0) rotate(var(--rot,0deg)); }
    88%  { transform: translateY(115%) rotate(var(--rot,0deg)); }
    100% { transform: translateY(115%) rotate(var(--rot,0deg)); }
  }
  .drop-now { animation: drop .7s ease-in forwards; }

  /* Optional puddle grow (kept, but no opacity fade) */
  @keyframes puddle {
    0%   { transform: scale(.2); }
    100% { transform: scale(1);  }
  }
  .puddle { opacity:1; transform:scale(.2); } /* visible by default but tiny */
  .puddle-grow { animation: puddle .9s ease-out forwards; }

  /* Mobile layout */
  @media (max-width: 860px){ .app{grid-template-columns:1fr} }
</style>
</head>
<body>
  <div class="app">
    <!-- Left: controls -->
    <div class="card" role="region" aria-label="Game controls">
      <h1>Melting Snowman Hangman</h1>
      <div class="meta">
        <div class="tag">Lives: <span id="lives">–</span></div>
        <div class="tag">Category: <span id="category">Holiday</span></div>
      </div>

      <div id="blanks" class="blanks" aria-live="polite"></div>
      <p class="used">Used: <span id="used"></span></p>

      <div id="keyboard" class="keyboard" aria-label="On-screen keyboard"></div>

      <div class="actions">
        <button id="new">New Word</button>
        <button id="hint">Hint (–1 life)</button>
        <button id="reveal">Reveal</button>
      </div>

      <div id="status" class="status" aria-live="polite"></div>
    </div>

    <!-- Right: your snowman art -->
    <div class="card scene" role="region" aria-label="Snowman scene">
      <div class="ground"></div>
      <!-- Export every PNG from the SAME Canva canvas size. Place into /images -->
      <div class="snowman-wrap" aria-hidden="true">
        <img src="images/bottom.png"     class="part bottom"     alt="">
        <img src="images/torso.png"      class="part torso"      alt="">
        <img src="images/head.png"       class="part head"       alt="">
        <img src="images/eye-left.png"   class="part eye-left"   alt="">
        <img src="images/eye-right.png"  class="part eye-right"  alt="">
        <img src="images/brow-left.png"  class="part brow-left"  alt="">
        <img src="images/brow-right.png" class="part brow-right" alt="">
        <img src="images/nose.png"       class="part nose"       alt="">
        <img src="images/scarf.png"      class="part scarf"      alt="">
        <img src="images/arm-left.png"   class="part arm-left"   alt="">
        <img src="images/arm-right.png"  class="part arm-right"  alt="">
        <img src="images/hat.png"        class="part hat"        alt="">
        <!-- optional puddle image (starts small; grows on the final step) -->
        <img src="images/puddle.png"     class="part puddle"     alt="">
      </div>
    </div>
  </div>

<script>
(() => {
  /* =================== CONFIG =================== */
  const WORDS = [
    "MISTLETOE","SLEIGH BELLS","WINTER WONDERLAND","GINGERBREAD","CANDY CANE",
    "SNOWFLAKE","NORTH POLE","FRUITCAKE","ELF ON THE SHELF","SILENT NIGHT",
    "HOT COCOA","UGLY SWEATER","JINGLE BELLS","REINDEER GAMES","HOLIDAY CHEER",
    "CHRISTMAS CAROLS","STOCKING STUFFER","SUGAR PLUM FAIRY","TINSEL TOWN","NAUGHTY OR NICE",
    "SECRET SANTA","WHITE ELEPHANT","YULE LOG","PEPPERMINT BARK","GIFT WRAP",
    "SANTAS WORKSHOP","CHRISTMAS LIGHTS","WINTER SOLSTICE","HOLIDAY MOVIE MARATHON","NORTH STAR",
    "FROSTY THE SNOWMAN","RUDOLPH THE RED NOSED REINDEER","SILVER BELLS","CAROLING DOOR TO DOOR","COOKIES AND MILK",
    "CHESTNUTS ROASTING","HOLIDAY SPIRIT","DECK THE HALLS","THE NUTCRACKER","POLAR EXPRESS",
    "SNOWBALL FIGHT","FAMILY DINNER","HOLIDAY BONUS","OFFICE PARTY","NEW YEARS EVE",
    "ADVENT CALENDAR","CANDY CANE LANE","GINGERBREAD HOUSE","WINTER COAT","WASSAIL","SUGAR COOKIES"
  ];

  /* PARTS: order of drops (one per wrong guess).
     You can reorder this array to change the sequence.
     Each item: { sel: '.css-class', rot: degrees }  (rot optional)
  */
  const DROP_SEQUENCE = [
    { sel: '.hat',        rot: -12 },
    { sel: '.brow-left',  rot: -6  },
    { sel: '.brow-right', rot:  6  },
    { sel: '.eye-left',   rot: -3  },
    { sel: '.eye-right',  rot:  3  },
    { sel: '.nose',       rot:  8  },
    { sel: '.scarf',      rot: -10 },
    { sel: '.arm-left',   rot: -14 },
    { sel: '.arm-right',  rot:  14 },
    { sel: '.head',       rot:  10 },
    { sel: '.torso',      rot:  6  },
    { sel: '.bottom',     rot:  4  },
    // Final step (if present) will grow the puddle instead of dropping it
    // Puddle is handled separately so it doesn't disappear below the ground.
  ];

  const HAS_PUDDLE = !!document.querySelector('.puddle');
  const MAX_LIVES = DROP_SEQUENCE.length + (HAS_PUDDLE ? 1 : 0);

  /* =================== DOM =================== */
  const blanksEl = document.getElementById('blanks');
  const keyboardEl = document.getElementById('keyboard');
  const usedEl = document.getElementById('used');
  const livesEl = document.getElementById('lives');
  const statusEl = document.getElementById('status');
  const newBtn = document.getElementById('new');
  const hintBtn = document.getElementById('hint');
  const revealBtn = document.getElementById('reveal');

  /* =================== STATE =================== */
  let answer, revealed, used, lives, wrongs;

  function $(sel){ return document.querySelector(sel); }
  function pickWord(){ return WORDS[Math.floor(Math.random()*WORDS.length)]; }

  function reset(word=null){
    answer = (word || pickWord()).toUpperCase();
    revealed = answer.split('').map(ch => ch===' '? ' ' : (/[A-Z]/.test(ch)? '_' : ch));
    used = [];
    lives = MAX_LIVES;
    wrongs = 0;
    blanksEl.innerHTML = '';
    usedEl.textContent = '';
    livesEl.textContent = lives;
    statusEl.textContent = '';
    renderBlanks();
    renderKeyboard();
    resetParts();
  }

  /* =================== RENDER =================== */
  function renderBlanks(){
    blanksEl.innerHTML = '';
    revealed.forEach(ch=>{
      const s = document.createElement('span');
      s.className = 'blank' + (ch===' ' ? ' space':'');
      s.textContent = ch===' ' ? ' ' : ch;
      blanksEl.appendChild(s);
    });
  }

  function renderKeyboard(){
    keyboardEl.innerHTML = '';
    'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('').forEach(l=>{
      const b = document.createElement('button');
      b.className = 'key';
      b.textContent = l;
      b.disabled = used?.includes(l) || isFinished();
      b.addEventListener('click', ()=> guess(l));
      keyboardEl.appendChild(b);
    });
  }

  function updateUsed(letter){
    used.push(letter);
    usedEl.textContent = used.join(' ');
  }

  function isFinished(){ return lives<=0 || !revealed.includes('_'); }

  /* =================== GAMEPLAY =================== */
  function guess(letter){
    if (used.includes(letter) || isFinished()) return;
    updateUsed(letter);

    if (answer.includes(letter)){
      answer.split('').forEach((ch,i)=>{ if (ch===letter) revealed[i]=letter; });
      renderBlanks();
      if (!revealed.includes('_')){
        statusEl.innerHTML = `<span class="good">You win!</span> The phrase was <strong>${answer}</strong>.`;
        renderKeyboard();
      }
    } else {
      wrongStep();
    }
    renderKeyboard();
  }

  function wrongStep(){
    if (wrongs < DROP_SEQUENCE.length){
      const step = DROP_SEQUENCE[wrongs];
      const part = $(step.sel);
      if (part){
        part.style.setProperty('--rot', (step.rot||0) + 'deg');
        // replay animation
        part.classList.remove('drop-now'); void part.offsetWidth; part.classList.add('drop-now');
      }
    } else if (HAS_PUDDLE){
      const puddle = $('.puddle');
      if (puddle){
        puddle.classList.remove('puddle-grow'); void puddle.offsetWidth; puddle.classList.add('puddle-grow');
      }
    }
    wrongs++;
    lives--;
    livesEl.textContent = lives;

    if (lives<=0){
      statusEl.innerHTML = `<span class="bad">You lose!</span> The phrase was <strong>${answer}</strong>.`;
      revealAll();
      renderKeyboard();
    }
  }

  function revealAll(){
    revealed = answer.split('').map(ch => ch===' ' ? ' ' : ch);
    renderBlanks();
  }

  function resetParts(){
    // Clear all per-part animations and transforms
    DROP_SEQUENCE.forEach(({sel})=>{
      const el = $(sel);
      if (!el) return;
      el.classList.remove('drop-now');
      el.style.transform = '';
      el.style.animation = 'none';
      void el.offsetWidth; // reflow
    });
    if (HAS_PUDDLE){
      const puddle = $('.puddle');
      if (puddle){
        puddle.classList.remove('puddle-grow');
        puddle.style.transform = 'scale(.2)';
        void puddle.offsetWidth;
      }
    }
  }

  /* =================== HINT =================== */
  function hint(){
    if (isFinished() || lives<=0) return;
    const set = new Set();
    answer.split('').forEach((ch,i)=>{ if (/[A-Z]/.test(ch) && revealed[i]==='_') set.add(ch); });
    const options = [...set];
    if (!options.length) return;
    const letter = options[Math.floor(Math.random()*options.length)];
    answer.split('').forEach((ch,i)=>{ if (ch===letter) revealed[i]=letter; });
    if (!used.includes(letter)) updateUsed(letter);
    renderBlanks();
    // Hint costs one life and triggers a drop
    wrongStep();
    if (!revealed.includes('_') && lives>=0){
      statusEl.innerHTML = `<span class="good">Solved with a hint!</span> The phrase was <strong>${answer}</strong>.`;
    }
    renderKeyboard();
  }

  /* =================== CONTROLS =================== */
  newBtn.addEventListener('click', ()=> reset());
  revealBtn.addEventListener('click', ()=>{
    statusEl.innerHTML = `<span class="bad">Revealed.</span> The phrase was <strong>${answer}</strong>.`;
    revealAll(); renderKeyboard();
  });
  hintBtn.addEventListener('click', hint);

  // Physical keyboard support
  window.addEventListener('keydown', (e)=>{
    const k = e.key.toUpperCase();
    if (/^[A-Z]$/.test(k)) guess(k);
  });

  // Start
  reset();
})();
</script>
</body>
</html>